


<!-- This piece of code is to say that the data of the nodes is bound to the -->
<!-- rectangles on screen. After every update - synchronously the rectangles change -->
<!-- color based on the current values of the cells. -->

<!-- need to figure out the drag and drop functionality. -->


<html>
  <head>
    <script type="text/javascript" src="http://d3js.org/d3.v3.min.js"> </script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"> </script>

    <style>

      .container{
        display: flex;
        width: 6%;
      }

      .bordered{
        outline: 4px solid black;
      }

      .testinprogress{
        outline: 3px dotted black;
      }

      .testing {
        touch-action: none;
        user-select: none;
        flex-grow: 1;
      }

      .disconnect {
        touch-action: none;
        user-select: none;
        flex-grow: 1;
      }

      .connect {
        touch-action: none;
        user-select: none;
        flex-grow: 1;
      }

    </style>
  </head>

  <body>

    <div class="container">
      <div class="testing" style="background:black;color:white" > T </div> &nbsp
      <div class="disconnect" style="background:black;color:white" > D </div> &nbsp
      <div class="connect" style="background:black;color:white" > C </div> &nbsp
    </div>

    <br>

    <p id="ts"> </p>
    <script type="text/javascript" src="graphs.js"> </script>

    <script>

      // N1*N2 grids
      var n1 = 20;
      var n2 = 10;
      var ts = 0;

      console.log("\nSimulation runs with " + n1 + "*" + n2 + "cells for " + iterations + " iterations.");
      console.log("Every time step : " + disconnect + "% of cells are disconnected, and " + testing + "% of cells are tested");
      console.log("Scoring: Score = green cells + adjacent green cells (counted once)");


      let rects = [];

      for (i = 0 ; i < n1; i++){
          for(j =0; j<n2; j++){
              var color = "green"
              var r = Math.random()
              if( r < 0.3 ){
                  color = "green"
              }
              else if( r >= 0.3 && r < 0.6 ){
                  color = "orange"
              }
              else{
                  color = "red"
              }
              rects.push({"x": j, "y": i, "color": color});
          }
      }

      populate_grid(n1,n2);

      var svgContainer = d3.select("body").append("svg")
          .attr("width", 600)
          .attr("height", 600);

      var rectangles = svgContainer.selectAll("rect")
          .data(rects)
          .enter()
          .append("rect");

      rectangles
        .attr('x', function(d) {
            return d.x * 30;
        })
        .attr('y', function(d) {
            return d.y * 30;
        })
        .attr("width",25)
        .attr("height", 25)
        .style("fill","white")
        .attr("cx",function(d){
           return d.x
       })
       .attr("cy", function(d){
         return d.y
       })
       .attr("class","dropzone")

      // function(d) {
      //       return d.color;

      document.getElementById("ts").innerHTML = "Time step: " + (ts++) +  "\n" + "Score:" + cagrid.score();

      // .attr('x', function(d) {
          //     return d.x * 30;
          // })
          // .attr('y', function(d) {
          //     return d.y * 30;
          // })
          // .attr("width",25)
          // .attr("height", 25)
          // .style("fill",function(d) {
          //     if( d.color > 0.5 ){
          //         return "green"
          //     }
          //     else{
          //         return "red"
          //     }
          // });

      // d3.selectAll("rect")
      // .on("mouseover", function(d, i) { rects[i].color = Math.random(); update() });

      function update(){

          document.getElementById("ts").innerHTML = "Time step: " + (ts++) +  "\n" + "Score:" + cagrid.score();
          //var obj = cagrid.orderExport();
          for(var iter=0; iter<rects.length; iter++){
              var objColor = cagrid.retrieveColor(rects[iter].y + "," + rects[iter].x)
              rects[iter].color = objColor;
          }

          svgContainer
              .selectAll("rect")
              .transition()
              .style("fill", function(d){
                  return d.color
              })

          // var rectangles = svgContainer.selectAll("rect")
          //     .data(rects)
          //     .enter()
          //     .append("rect");

          // rectangles
          //     .attr('x', function(d) {
          //         return d.x * 30;
          //     })
          //     .attr('y', function(d) {
          //         return d.y * 30;
          //     })
          //     .attr("width",25)
          //     .attr("height", 25)
          //     .style("fill",function(d) {
          //         return d.color;
          //     })
          //     .attr("cx",function(d){
          //         return d.x
          //     })
          //     .attr("cy", function(d){
          //         return d.y
          //     })
          //     .attr("class","dropzone")

          run_grid(n1,n2);
      }

     interact('.dropzone')
    .dropzone({
        accept: ['.testing','.disconnect','.connect'],
        overlap: 0.5,
        ondrop: function (event) {
            console.log(event.relatedTarget.getAttribute("class"));
            var x = event.target.getAttribute("cx");
            var y = event.target.getAttribute("cy");

            switch(event.relatedTarget.getAttribute("class")){
            case "testing": {
                cagrid.testing(y+","+x, 1);
                const item = event.target
                item.classList.add('testinprogress')
            } break;
            case "disconnect": {
                cagrid.disconnect(y+","+x, 1);
                const item = event.target
                item.classList.add('bordered')
            } break;
            case "connect": {
                cagrid.disconnect(y+","+x, 0);
                const item = event.target;
                item.classList.remove('bordered')
                item.classList.remove('testinprogress')
                cagrid.testing(y+","+x, 0);
            } break;
            default: {cagrid.testing(y+","+x, 0);cagrid.disconnect(y+","+x, 0);}
            }
        }
    });

      interact('.testing')
      .draggable({
        onmove: function(event) {
            const target = event.target;

            const dataX = target.getAttribute('data-x');
            const dataY = target.getAttribute('data-y');
            const initialX = parseFloat(dataX) || 0;
            const initialY = parseFloat(dataY) || 0;

            const deltaX = event.dx;
            const deltaY = event.dy;

            const newX = initialX + deltaX;
            const newY = initialY + deltaY;

            target
                .style
                .transform = `translate(${newX}px, ${newY}px)`;

            target.setAttribute('data-x', newX);
            target.setAttribute('data-y', newY);
        },
        inertia: true,
      })

      interact('.disconnect')
      .draggable({
        onmove: function(event) {
            const target = event.target;

            const dataX = target.getAttribute('data-x');
            const dataY = target.getAttribute('data-y');
            const initialX = parseFloat(dataX) || 0;
            const initialY = parseFloat(dataY) || 0;

            const deltaX = event.dx;
            const deltaY = event.dy;

            const newX = initialX + deltaX;
            const newY = initialY + deltaY;

            target
                .style
                .transform = `translate(${newX}px, ${newY}px)`;

            target.setAttribute('data-x', newX);
            target.setAttribute('data-y', newY);
        },
        inertia: true,
    })

      interact('.connect')
    .draggable({
        onmove: function(event) {
            const target = event.target;

            const dataX = target.getAttribute('data-x');
            const dataY = target.getAttribute('data-y');
            const initialX = parseFloat(dataX) || 0;
            const initialY = parseFloat(dataY) || 0;

            const deltaX = event.dx;
            const deltaY = event.dy;

            const newX = initialX + deltaX;
            const newY = initialY + deltaY;

            target
                .style
                .transform = `translate(${newX}px, ${newY}px)`;

            target.setAttribute('data-x', newX);
            target.setAttribute('data-y', newY);
        }
    })

      update();
      cagrid.gridDisplay(n1,n2)
      setInterval(update, 5000);

    </script>
  </body>

</html>
